# A0131507R
###### src\gridtask\common\Task.java
``` java
package gridtask.common;

import java.text.ParseException;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;

/**
 * Represents a single task with task details.
 *
 * Floating task - no end date
 * Deadline task - has end date only
 * Event task - has start and end dates
 */
public class Task implements Comparable<Task> {

    // Task details
    private String description;
    private int id;
    private LocalDateTime start;
    private LocalDateTime end;
    private ArrayList<String> categories;
    private boolean isImportant;
    private boolean isModified;
    
    // Return values for compareTo method defined in Comparable interface
    private static final int GREATER_THAN = 1;
    private static final int LESS_THAN = -1;

    // For formatting start and end dates/times of different task types
    private static final String TASK_DETAILS_DATE_FLOATING = "From %s";
    private static final String TASK_DETAILS_DATE_DEADLINE = "By %s";
    private static final String TASK_DETAILS_DATE_EVENT = "From %s to %s";
    private static final String TASK_DETAILS_DATE_EVENT_ONE_DAY = "On %s, from %s to %s";
    
    // For formatting the String representation of a Task
    private static final String TASK_STRING = "%s|%s|%s|%s|%s|%s";
    private static final String TASK_STRING_NO_ID = "%s|%s|%s|%s|%s";
    
    // For formatting a LocalDateTime into a String
    private static final DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm");
    private static final DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("dd/MM/yyyy");
    private static final DateTimeFormatter timeFormatter = DateTimeFormatter.ofPattern("HH:mm");

    /**
     * Class constructor specifying the task description
     */
    public Task(String description) {
        this(description, null, null, 0);
    }
    
    /**
     * Class constructor specifying the task description and id
     */
    public Task(String description, int id) {
        this(description, null, null, id);
    }
    
    /**
     * Class constructor specifying the task description and date/time
     */
    public Task(String description, LocalDateTime start, LocalDateTime end) {
        this(description, start, end, 0);
    }
    
    /**
     * Class constructor specifying the task description, date/time and id
     */
    public Task(String description, LocalDateTime start, LocalDateTime end, int id) {
        this.description = description;
        this.start = start;
        this.end = end;
        this.id = id;
        categories = new ArrayList<String>();
        isImportant = false;
        isModified = false;
    }

    /******************
     * GETTER METHODS *
     ******************/
    
    public String getDescription() {
        return description;
    }
    
    public int getId() {
        return id;
    }
    
    public LocalDateTime getStart() {
        return start;
    }
    
    public LocalDate getStartDate() {
        if (start != null) {
            return start.toLocalDate();
        }
        return null;
    }
    
    /**
     * Returns the start date/time formatted as dd/MM/yyyy HH:mm.
     * A task without a start date/time will return an empty String.
     * 
     * @return          the formatted start date
     */
    public String getStartString() {
        if (start != null) {
            return formatDateTime(start);
        }
        return "";
    }
    
    /**
     * Returns the start date/time formatted as dd/MM/yyyy HH:mm, relative to the given date.
     * If the start date is the same the given date, returns only HH:mm.
     * A task without a start date/time will return an empty String.
     * 
     * @return          the formatted start date
     */
    public String getRelativeStartString(LocalDate now) {
        if (start != null) {
            return formatRelativeDateTime(start, now);
        }
        return "";
    }

    public LocalDateTime getEnd() {
        return end;
    }
    
    public LocalDate getEndDate() {
        if (end != null) {
            return end.toLocalDate();
        }
        return null;
    }
    
    /**
     * Returns the end date/time formatted as dd/MM/yyyy HH:mm.
     * A floating task will return an empty String.
     * 
     * @return          the formatted end date
     */
    public String getEndString() {
        if (end != null) {
            return formatDateTime(end);
        }
        return "";
    }
    
    /**
     * Returns the end date/time formatted as dd/MM/yyyy HH:mm, relative to the given date.
     * If the end date is the same the given date, returns only HH:mm.
     * A floating task will return an empty String.
     * 
     * @return          the formatted end date
     */
    public String getRelativeEndString(LocalDate now) {
        if (end != null) {
            return formatRelativeDateTime(end, now);
        }
        return "";
    }
    
    /**
     * Returns the start, end date/time formatted based on the task type.
     * For example, an event is formatted as "From dd/MM/yyyy HH:mm to dd/MM/yyy HH:mm".
     * 
     * @return          the formatted start and end date
     */
    public String getStartEndString() {
        String startEndString = "";
        if (isFloating()) {
            if (start != null) {
                String startString = getStartString();
                startEndString = String.format(TASK_DETAILS_DATE_FLOATING, startString);
            }
        } else if (isDeadline()) {
            String endString = getEndString();
            startEndString = String.format(TASK_DETAILS_DATE_DEADLINE, endString);
        } else if (isEvent()) {
            String startString = getStartString();
            String endString = getEndString();
            startEndString = String.format(TASK_DETAILS_DATE_EVENT, startString, endString);
        }
        return startEndString;
    }
    
    /**
     * Returns the start, end date/time formatted based on the task type, relative to the given date.
     * For example, an event occurring on the same day is formatted as "From HH:mm to HH:mm".
     * 
     * @return          the formatted start and end date
     */
    public String getRelativeStartEndString(LocalDate now) {
        String startEndString = "";
        if (isFloating()) {
            if (start != null) {
                String startString = getRelativeStartString(now);
                startEndString = String.format(TASK_DETAILS_DATE_FLOATING, startString);
            }
        } else if (isDeadline()) {
            String endString = getRelativeEndString(now);
            startEndString = String.format(TASK_DETAILS_DATE_DEADLINE, endString);
        } else if (isEvent()) {
            LocalDate startDate = getStartDate();
            LocalDate endDate = getEndDate();
            if (startDate.isEqual(endDate) && !startDate.isEqual(now)) {
                String startString = getRelativeStartString(startDate);
                String endString = getRelativeEndString(endDate);
                String date = dateFormatter.format(start);
                startEndString = String.format(TASK_DETAILS_DATE_EVENT_ONE_DAY, date, startString, endString);
            } else {
                String startString = formatRelativeDateTime(start, now);
                String endString = formatRelativeDateTime(end, now);
                startEndString = String.format(TASK_DETAILS_DATE_EVENT, startString, endString);
            }
        }
        return startEndString;
    }

    public ArrayList<String> getCategories() {
        return categories;
    }
    
    /**
     * Returns the categories associated with this task in a formatted String.
     * 
     * @return          the formatted String of categories
     */
    public String getCategoriesString() {
        String allCategories = "";
        for (String cat : categories) {
            allCategories += " #" + cat;
        }
        return allCategories.trim();
    }

    public boolean isImportant() {
        return isImportant;
    }
    
    public boolean isModified() {
        return isModified;
    }
    
    /******************
     * SETTER METHODS *
     ******************/
    
    public void setDescription(String line) {
        description = line;
    }
    
    public void setId(int index) {
        id = index;
    }
        
    public void setStart(LocalDateTime date) {
        start = date;
    }
    
    public void setStart(String date) throws ParseException {
        LocalDateTime startDate = LocalDateTime.parse(date, dateTimeFormatter);
        this.start = startDate;
    }

    public void setEnd(LocalDateTime date) {
        end = date;
    }
    
    public void setEnd(String date) throws ParseException {
        LocalDateTime endDate = LocalDateTime.parse(date, dateTimeFormatter);
        this.end = endDate;
    }

    public void setCategories(ArrayList<String> categories) {
        this.categories = categories;
    }
    
    public void setImportant(boolean isImportant) {
        this.isImportant = isImportant;
    }
        
    public void setModified(boolean isModified) {
        this.isModified = isModified;
    }
    
    /******************
     * HELPER METHODS *
     ******************/
    
    /**
     * Checks if this task is overdue relative to the given date and time.
     * Returns true if and only if this task ends before the date and time.
     * If this task is a floating task, returns false.
     * 
     * @param dateTime  date and time for comparison 
     * @return          true if end is earlier than dateTime
     */
    public boolean isOverdue(LocalDateTime dateTime) {
        if (isEvent() || isDeadline()) {
            return end.isBefore(dateTime);
        }
        return false;
    }
    
    /**
     * Returns true if this task occurs on the given date.
     * 
     * @param date      date for comparison
     * @return          true if given date falls between start or end
     */
    public boolean isOccurringOn(LocalDate date) {
        if (isFloating()) {
            if (start != null) {
                LocalDate startDate = start.toLocalDate();
                return startDate.isEqual(date);
            }
            return false;
        } else if (isEvent()) {
            LocalDate startDate = start.toLocalDate();
            LocalDate endDate = end.toLocalDate();
            boolean isBefore = date.isBefore(startDate);
            boolean isAfter = date.isAfter(endDate);
            return !isBefore && !isAfter;
        } else if (isDeadline()) {
            LocalDate endDate = end.toLocalDate();
            return endDate.isEqual(date);
        }
        return false;
    }
    
    /**
     * Compares this task to another task.
     * Comparison is mainly based on the start and end date/time. If the
     * dates are equal, then the task description is used for comparison.
     * Use to facilitate sorting methods.
     * 
     * @param t2        the other task to compare to
     * @return          0 if the tasks are equal, a negative integer if
     *                  this task is less than the specified task, and a
     *                  positive integer if this task is greater than the
     *                  specified task
     */
    public int compareTo(Task t2) {
        if (t2 == null) {
            throw new NullPointerException();
        }
        if (this.isFloating()) {
            return compareFloatingTo(t2);
        } else if (this.isDeadline()) {
            return compareDeadlineTo(t2);
        } else if (this.isEvent()) {
            return compareEventTo(t2);
        }
        return this.description.compareTo(t2.description);
    }
    
    private int compareEventTo(Task t2) {
        if (t2.isFloating()) {
            return LESS_THAN;
        } else {
            int endComparison = this.end.compareTo(t2.end);
            if (endComparison == 0) {
                if (t2.isDeadline()) {
                    return this.description.compareTo(t2.description);
                }
                int startComparison = this.start.compareTo(t2.start);
                if (startComparison == 0) {
                    return this.description.compareTo(t2.description);
                }
                return startComparison;
            }
            return endComparison; 
        }
    }

    private int compareDeadlineTo(Task t2) {
        if (t2.isFloating()) {
            return LESS_THAN;
        } else {
            int compare = this.end.compareTo(t2.end);
            if (compare == 0) {
                return this.description.compareTo(t2.description);
            }
            return compare;
        }
    }

    private int compareFloatingTo(Task t2) {
        if (t2.isFloating()) {
            // order lexicographically
            return this.description.compareTo(t2.description);
        } else {
            return GREATER_THAN;
        }
    }

    /**
     * Returns true if this task is a floating task.
     * A floating task is a task that does not have a start or end date.
     * 
     * @return          true if task is floating
     */
    public boolean isFloating() {
        boolean hasEnd = this.end != null;
        return !hasEnd;
    }
    
    /**
     * Returns true if this task is an event.
     * An event is a task that takes place within a specified period,
     * i.e. has a start and end date.
     * 
     * @return          true if task is an event
     */
    public boolean isEvent() {
        boolean hasStart = this.start != null;
        boolean hasEnd = this.end != null;
        return hasStart && hasEnd;
    }
    
    /**
     * Returns true if this task is a deadline.
     * A deadline is a task that has an end date, but no start date.
     * 
     * @return          true if task is a deadline
     */
    public boolean isDeadline() {
        boolean hasStart = this.start != null;
        boolean hasEnd = this.end != null;
        return !hasStart && hasEnd;
    }
    
    @Override
    /**
     * Represents this task as a String.
     * 
     * @return          a String representation of this task, not null
     */
    public String toString() {
        String startStr = null;
        if (start != null) {
            startStr = dateTimeFormatter.format(start);
        }
        String endStr = null;
        if (end != null) {
            endStr = dateTimeFormatter.format(end);
        }
        String catStr = "";
        for (String cat : categories) {
            catStr += "#" + cat;
        }
        String task = String.format(TASK_STRING, description, id,
                startStr, endStr, catStr.isEmpty() ? null : catStr, isImportant);
        return task;
    }
    
    public String toStringIgnoreId() {
        String startStr = null;
        if (start != null) {
            startStr = dateTimeFormatter.format(start);
        }
        String endStr = null;
        if (end != null) {
            endStr = dateTimeFormatter.format(end);
        }
        String catStr = "";
        for (String cat : categories) {
            catStr += "#" + cat;
        }
        String task = String.format(TASK_STRING_NO_ID, description,
                startStr, endStr, catStr.isEmpty() ? null : catStr, isImportant);
        return task;
    }
    
    @Override
    public boolean equals(Object o) {
        if (o instanceof Task) {
            Task t2 = (Task) o;
            return this.toString().equals(t2.toString());
        }
        return false;
    }
    
    private String formatDateTime(LocalDateTime dateTime) {
        return dateTimeFormatter.format(dateTime);
    }
    
    private String formatRelativeDateTime(LocalDateTime dateTime, LocalDate now) {
        if (dateTime.toLocalDate().isEqual(now)) {
            return timeFormatter.format(dateTime);
        } else {
            return dateTimeFormatter.format(dateTime);
        }
    }

}
```
###### src\gridtask\logic\Execution.java
``` java
    private void saveAutoCompletionList() {
        // convert TreeSet to ArrayList
    	ArrayList<Entry<String,Integer>> autoCompletionList = new ArrayList<Entry<String,Integer>>();
        for (Entry<String, Integer> entry : taskDictionary) {
            autoCompletionList.add(entry);
        }
        storage.setAutoCompletionList(autoCompletionList);
        try {
            storage.writeAutoCompletionData();
        } catch (IOException ioe) {
            // do nothing here
        }
    }

    private void updateTaskDictionary(String text) {
        int freqCount = removeFromTreeSet(taskDictionary, text);
        addToTreeSet(taskDictionary, text, ++freqCount);
    }

    private void updateWordDictionary(String text) {
        String[] words = text.toLowerCase().split("\\s+");
        for (int i = 0; i < words.length; i++) {
            if (!isNumberOrFunctionWord(words[i])) {
                int freqCount = removeFromTreeSet(wordDictionary, words[i]);
                addToTreeSet(wordDictionary, words[i], ++freqCount);
            }
        }
    }

    private void updateFileDictionary(String text) {
        int freqCount = removeFromTreeSet(fileDictionary, text);
        addToTreeSet(fileDictionary, text, ++freqCount);
    }

    // Remove the text from the tree set if it exists and return its frequency
    // count
    // If it does not already exist in the tree set, frequency count is 0
    private int removeFromTreeSet(TreeSet<Entry<String, Integer>> treeSet, String text) {
        int freqCount = 0;
        Iterator<Entry<String, Integer>> iterator = treeSet.iterator();
        while (iterator.hasNext()) {
            Entry<String, Integer> next = iterator.next();
            if (next.getKey().equalsIgnoreCase(text)) {
                // Keep the frequency count and remove the entry
                freqCount = next.getValue();
                iterator.remove();
                break;
            }
        }
        return freqCount;
    }

    // Add the text to the tree set with its frequency count
    private void addToTreeSet(TreeSet<Entry<String, Integer>> treeSet, String text, int freqCount) {
        treeSet.add(new AbstractMap.SimpleEntry<String, Integer>(text, freqCount));
    }

    // Returns true if the specified word is a number or function word
    private boolean isNumberOrFunctionWord(String word) {
        // Check if word contains only numbers and the decimal separator
        if (word.matches("-?\\d+(\\.\\d+)?")) {
            return true;
        }
        // Check if word is a pre-defined function word
        // index will be >= 0 if it is
        String wordLowerCase = word.toLowerCase();
        int index = Arrays.binarySearch(functionWords, wordLowerCase, String.CASE_INSENSITIVE_ORDER);
        return index >= 0 ? true : false;
    }

```
###### src\gridtask\logic\Execution.java
``` java
    /**
     * Formats a string to sentence case.
     * Leading and trailing whitespace will be removed. The first non-whitespace character
     * is capitalised and the remaining text is converted to lower case
     * 
     * @param text      String to format
     * @return          String formatted in sentence case
     */
    private String toSentenceCase(String text) {
        if (text == null) {
            throw new NullPointerException();
        }
        String textTrimmed = text.trim();
        if (textTrimmed.isEmpty()) {
            return textTrimmed;
        }
        String sentenceCase = textTrimmed.substring(0, 1).toUpperCase();
        if (textTrimmed.length() > 1) {
            sentenceCase += textTrimmed.substring(1).toLowerCase();
        }
        return sentenceCase;
    }

}
```
###### src\gridtask\logic\Logic.java
``` java
    private ArrayList<String> getPredictionsForAdd(String[] params) {
        // Predictions based on task descriptions that user previously entered
        TreeSet<Entry<String, Integer>> dictionary = execution.getTaskDictionary();
        return getPredictionsFromDictionary(dictionary, params);
    }

    private ArrayList<String> getPredictionsForSearch(String[] params) {
        // Predictions based on words that user previously entered
        TreeSet<Entry<String, Integer>> dictionary = execution.getWordDictionary();
        return getPredictionsFromDictionary(dictionary, params);
    }

    private ArrayList<String> getPredictionsForEdit(String[] params) {
        assert (params.length > 0);

        // Maintain a unique set of prediction strings
        HashSet<String> hashSet = new HashSet<String>();
        // Predictions based on task descriptions that the user previously entered
        TreeSet<Entry<String, Integer>> dictionary = execution.getTaskDictionary();
        // List of task descriptions sorted by frequency
        ArrayList<Entry<String, Integer>> freqList;

        assert (dictionary != null);

        String command = params[0];
        if (params.length == 2) {
            try {
                // retrieve task description
                int id = Integer.parseInt(params[1]);
                String desc = execution.getMainList().get(id-1).getDescription();
                hashSet.add(command + " " + id + " " + desc);

                // retrieve all entries, sorted by frequency
                freqList = sortByFrequency(dictionary);

                // get maximum number of predictions
                for (Entry<String, Integer> entry : freqList) {
                    String prediction = entry.getKey();
                    hashSet.add(command + " " + id + " " + prediction);
                    if (hashSet.size() == MAX_PREDICTIONS) {
                        break;
                    }
                }
            } catch (NumberFormatException | IndexOutOfBoundsException e) {
                // wrong task index, no predictions given
            }
        }

        ArrayList<String> predictions = new ArrayList<String>();
        predictions.addAll(hashSet);
        return predictions;
    }

    private ArrayList<String> getPredictionsForSaveLoad(String[] params) {
        // Predictions based on directories/file names the user previously entered
        TreeSet<Entry<String, Integer>> dictionary = execution.getFileDictionary();
        return getPredictionsFromDictionary(dictionary, params);
    }

    private ArrayList<String> getPredictionsFromDictionary(
            TreeSet<Entry<String, Integer>> dictionary, String[] params) {
        assert (dictionary != null);
        assert (params.length > 0);

        // Maintain a unique set of prediction strings
        HashSet<String> hashSet = new HashSet<String>();
        // List of task descriptions sorted by frequency
        ArrayList<Entry<String, Integer>> freqList;

        String command = params[0];
        if (params.length == 1) {
            // retrieve all entries, sorted by frequency
            freqList = sortByFrequency(dictionary);
        } else {
            String minArg = params[1];
            int lastIndex = minArg.length() - 1;
            char c = minArg.charAt(lastIndex);
            c++;
            String maxArg = minArg.substring(0, lastIndex) + c;
            Entry<String, Integer> min = new AbstractMap.SimpleEntry<String, Integer>(minArg, 1);
            Entry<String, Integer> max = new AbstractMap.SimpleEntry<String, Integer>(maxArg, 1);

            // retrieve subset of entries matching user input, sorted by frequency
            SortedSet<Entry<String,Integer>> matches = dictionary.subSet(min, true, max, false);
            freqList = sortByFrequency(matches);
        }

        // get maximum number of predictions
        for (Entry<String, Integer> entry : freqList) {
            String prediction = entry.getKey();
            hashSet.add(command + " " + prediction + " ");
            if (hashSet.size() == MAX_PREDICTIONS) {
                break;
            }
        }

        ArrayList<String> predictions = new ArrayList<String>();
        predictions.addAll(hashSet);
        return predictions;
    }

    private ArrayList<Entry<String, Integer>> sortByFrequency(Set<Entry<String, Integer>> dictionary) {
        ArrayList<Entry<String, Integer>> freq = new ArrayList<Entry<String, Integer>>();
        freq.addAll(dictionary);
        freq.sort(freqComparator.reversed());
        return freq;
    }

}
```
###### src\gridtask\ui\display.css
``` css

/*************************
 * DEFAULT STYLE CLASSES *
 *************************/

/* reduce font aliasing  */
.text {
    -fx-font-smoothing-type: gray;
}

.label {
    -fx-font-size: 18;
    -fx-font-family: "Roboto Regular", "Segoe UI", sans-serif;
    -fx-alignment: center-left;
    -fx-label-padding: 3 4 3 4;
}

.list-view {
    -fx-padding: 0;
    -fx-background-color: transparent;
    -fx-border-color: none;
}

.list-cell {
    -fx-padding: 3 0 3 0;
    -fx-background-color: transparent;
}

.list-cell:empty {
    -fx-background-color: transparent;
}

.list-cell:selected .label {
    -fx-font-family: "Roboto Bold", "Segoe UI", sans-serif;
    -fx-text-fill: #000000;
}

.scroll-pane {
    -fx-focus-traversable: true;
    -fx-fit-to-width: true;
    -fx-hbar-policy: never;
    -fx-vbar-policy: as-needed;
    -fx-background-color: transparent;
}

.scroll-pane > .viewport {
    -fx-background-color: transparent;
}

.scroll-bar {
    -fx-opacity: 1;
    -fx-background-color: transparent;
    -fx-padding: 3 0 3 3;
}

.scroll-bar:vertical .track {
    -fx-background-color: transparent;
    -fx-background-radius: 0;
    -fx-background-insets: 0;
    -fx-border-width: 5;
    -fx-border-color: transparent;
}

.scroll-bar:vertical .thumb {
    -fx-background-color: #A1E7C6;
    -fx-background-radius: 0;
    -fx-background-insets: 1;
}

.scroll-bar:vertical .increment-button ,
.scroll-bar:vertical .decrement-button {
    -fx-background-color: transparent;
    -fx-padding: 0 10 0 0;
}

.scroll-bar .increment-arrow ,
.scroll-bar .decrement-arrow {
    -fx-shape: " ";
    -fx-padding: 0;
}

/************************
 * CUSTOM STYLE CLASSES *
 ************************/

.header {
    -fx-font-size: 25;
    -fx-font-family: "Roboto Slab Regular", "Segoe UI", sans-serif;
    -fx-alignment: center-left;
    -fx-label-padding: 5 5 0 5;
}

.panel {
    -fx-spacing: 3;
    -fx-padding: 5 15 5 15;
    -fx-background-color: #FFFFFF;
}

.entry-empty {
    -fx-padding: 3 5 3 5;
    -fx-background-color: #F2F2F2;
    -fx-pref-width: infinity;
}

.entry-task {
    /* prevents ListView from creating a horizontal scroll bar
     * when task description is wider than width of ListView*/
    -fx-pref-width: 1;
    -fx-padding: 3 5 3 5;
    -fx-background-color: #F2F2F2;
}

.entry-task-overdue {
    -fx-pref-width: 1;
    -fx-padding: 3 5 3 5;
    -fx-background-color: #FFAB8E;
}

.entry-task-modified {
    -fx-pref-width: 1;
    -fx-padding: 3 5 3 5;
    -fx-background-color: #A1E7C6;
}

.desc {
    -fx-wrap-text: true;
    -fx-text-alignment: left;
}

.details {
    -fx-alignment: center-left;
}

.details > .label {
    -fx-wrap-text: true;
    -fx-font-size: 15;
}

.table {
    -fx-padding: 3;
    -fx-vgap: 3;
    -fx-background-color: #F2F2F2;
}

.table .label {
    -fx-font-size: 18;
    -fx-wrap-text: true;
    -fx-font-family: "Roboto Condensed Regular", "Segoe UI", sans-serif;
}

.sidebar {
    -fx-alignment: top-left;
    -fx-padding: 5;
    -fx-spacing: 5;
    -fx-background-color: #F6F6F6;
    -fx-effect: dropshadow( gaussian , #AAAAAA , 10 , 0.1 , 0 , 0 );
}

.entry-cat {
    -fx-font-size: 20;
    -fx-padding: 3;
    -fx-alignment: center-left;
}

.count {
    -fx-font-size: 15;
    -fx-wrap-text: true;
    -fx-text-alignment: center;
    -fx-background-color: #A1E7C6;
    -fx-background-radius: 3;
}
```
###### src\gridtask\ui\Display.fxml
``` fxml
<?import javafx.scene.control.Label?>
<?import javafx.scene.control.ListView?>
<?import javafx.scene.control.ScrollPane?>
<?import javafx.scene.image.Image?>
<?import javafx.scene.image.ImageView?>
<?import javafx.scene.layout.ColumnConstraints?>
<?import javafx.scene.layout.GridPane?>
<?import javafx.scene.layout.Pane?>
<?import javafx.scene.layout.VBox?>
<?import org.controlsfx.control.HiddenSidesPane?>
<?import java.net.URL?>

<fx:root xmlns:fx="http://javafx.com/fxml/1" type="HiddenSidesPane" >
    <left>
        <VBox prefWidth="200" styleClass="sidebar">
            <Label text="Categories" styleClass="header" />
            <ScrollPane>
                <content>
                    <GridPane fx:id="categoryList" styleClass="sidebar-list">
                        <columnConstraints>
                            <ColumnConstraints hgrow="ALWAYS" halignment="LEFT" />
                            <ColumnConstraints halignment="RIGHT" />
                        </columnConstraints>
                    </GridPane>
                </content>
            </ScrollPane>
        </VBox>
    </left>
    
    <fx:define>
        <VBox fx:id="taskPanel" styleClass="panel">
            <ImageView>
                <image>
                    <Image url="@../../icons/sidebar.png" />
                </image>
            </ImageView>
            <Label text="Today" styleClass="header" />
            <VBox fx:id="todayList"></VBox>
            <Label text="Others" styleClass="header" />
            <VBox fx:id="otherList"></VBox>
        </VBox>
    </fx:define>
    <fx:define>
        <VBox fx:id="searchPanel" styleClass="panel">
        </VBox>
    </fx:define>
    <fx:define>
        <VBox fx:id="donePanel" styleClass="panel">
        </VBox>
    </fx:define>
    <fx:define>
        <VBox fx:id="helpPanel" styleClass="panel">
            <Label text="Help" styleClass="header" />
            <ScrollPane VBox.vgrow="SOMETIMES">
                <content>
                    <GridPane fx:id="helpList" styleClass="table">
                        <columnConstraints>
                            <ColumnConstraints percentWidth="30" />
                            <ColumnConstraints percentWidth="70" />
                        </columnConstraints>
                    </GridPane>
                </content>
            </ScrollPane>
        </VBox>
    </fx:define>
    
    <stylesheets>
        <URL value="@display.css" />
    </stylesheets>
</fx:root>
```
###### src\gridtask\ui\DisplayController.java
``` java
package gridtask.ui;

import java.io.IOException;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.logging.FileHandler;
import java.util.logging.Handler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;

import org.controlsfx.control.HiddenSidesPane;

import gridtask.common.Category;
import gridtask.common.Command.CommandType;
import gridtask.common.Result;
import gridtask.common.Task;
import javafx.beans.binding.Bindings;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.geometry.Side;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.control.ListView;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Priority;
import javafx.scene.layout.VBox;

public class DisplayController extends HiddenSidesPane {

    private static Logger logger = Logger.getLogger("MainApp.DisplayController");
    private MainApp main;
    
    @FXML private VBox taskPanel, searchPanel, donePanel, helpPanel;
    @FXML private GridPane categoryList, helpList;
    @FXML private VBox todayList, otherList;
    
    private static final int CELL_MIN_HEIGHT = 67;
    private static final int UNMODIFIED = -1;
    
    private static final String HEADER_DONE_SINGLE = " completed task";
    private static final String HEADER_DONE_PLURAL = " completed tasks";
    private static final String HEADER_SEARCH_SINGLE = " search result found";
    private static final String HEADER_SEARCH_PLURAL = " search results found";
    private static final String MESSAGE_EMPTY_LIST_TODAY = "No tasks due today!";
    private static final String MESSAGE_EMPTY_LIST_OTHER = "No other tasks due this week! "
                                                           + "Type 'search' to view all tasks.";

    private static final String FXML_DISPLAY = "Display.fxml";
    private static final String RESOURCES_ICON_PRIORITY = "/icons/priority.png";

    public DisplayController(MainApp main) {
        this.main = main;
        this.setFocusTraversable(false);
        initializeLogger();
        loadFXML();
        initializeTaskPanel();
        initializeHelpPanel();
        initializeSidebar();
    }

    private void initializeLogger() {
        try {
            Handler fh = new FileHandler("log_ui_display");
            logger.addHandler(fh);
            SimpleFormatter formatter = new SimpleFormatter();  
            fh.setFormatter(formatter);
        } catch (SecurityException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
    private void loadFXML() {
        FXMLLoader loader = new FXMLLoader(getClass().getResource(FXML_DISPLAY));
        loader.setController(this);
        loader.setRoot(this);
        try {
            loader.load();
        } catch (IOException e) {
            logger.log(Level.SEVERE, "failed to load Display", e);
        }
    }
    
    private void initializeTaskPanel() {
        ArrayList<Task> tasks = main.getTasks();
        populateTaskPanel(tasks);
        setMainPanelContent(taskPanel);
    }

    private void initializeHelpPanel() {
        String[] actions = { "Add a task",
                             "Edit a task",
                             "Search tasks",
                             "Mark as done",
                             "Search done tasks",
                             "Delete a task",
                             "Undo",
                             "Redo",
                             "Show help guide",
                             "Show tasks",
                             "Exit",
                             "Save file",
                             "Load file",
                             "View sidebar" };

        String[] commands = { "add <description> <date/time> #<category>",
                              "edit <task number> <new description> <new date/time> #<new category>",
                              "search <keyword / date / #category>",
                              "done <task number>",
                              "searchdone <keyword / date / #category>",
                              "delete <task number>",
                              "undo",
                              "redo",
                              "help",
                              "home",
                              "exit",
                              "save <directory> <filename>",
                              "load <directory> <filename>",
                              "CTRL+M" };
        
        assert (actions.length == commands.length);
        
        // add action and its corresponding command to the next row
        for (int row = 0; row < actions.length; row++) {
            Label action = new Label(actions[row]);
            helpList.add(action, 0, row);
            Label command = new Label(commands[row]);
            helpList.add(command, 1, row);
        }
    }

    private void initializeSidebar() {
        ArrayList<Category> categories = main.getCategories();
        populateSidebar(categories);
        this.setTriggerDistance(50);
    }
    
    /*******************************************
     * METHODS TO MANAGE DISPLAY OF MAIN PANEL *
     *******************************************/
    
    /**
     * Toggles the sidebar.
     * Opens the sidebar if it is closed and closes the sidebar if it is open.
     */
    public void toggleSidebar() {
        if (getPinnedSide() == Side.LEFT) {
            // close sidebar
            setPinnedSide(null);
        } else {
            // open sidebar
            setPinnedSide(Side.LEFT);
        }
    }
    
    /**
     * Displays the task results of the command to the user.
     * 
     * Invalid           no changes to main panel
     * Search            main panel shows search results
     * Searchdone        main panel shows completed tasks
     * Help              main panel shows help guide
     * Other commands    main panel shows tasks
     */
    public void displayResult(Result result) {
        assert (result != null);
        CommandType command = result.getCommandType();
        assert (command != null);
        ArrayList<Task> tasks = result.getResults();
        switch (command) {
            case INVALID :
                break;

            case SEARCH :
                populateSearchPanel(tasks);
                setMainPanelContent(searchPanel);
                break;
                
            case SEARCHDONE :
                populateDonePanel(tasks);
                setMainPanelContent(donePanel);
                break;
            
            case HELP :
                setMainPanelContent(helpPanel);
                break;

            default :
                ArrayList<Category> categories = main.getCategories();
                populateSidebar(categories);
                populateTaskPanel(tasks);
                setMainPanelContent(taskPanel);
                break;
        }
    }

    /**
     * Sets the specified node to be shown on the main panel.
     */
    private void setMainPanelContent(Node node) {
        this.setContent(node);
    }
    
    /********************************
     * METHODS TO UPDATE TASK PANEL *
     ********************************/

    /**
     * Populate the task panel with the specified tasks
     */
    private void populateTaskPanel(ArrayList<Task> tasks) {
        assert (tasks != null);
        populateTodayList(tasks);
        populateOtherList(tasks);
    }

    private void populateTodayList(ArrayList<Task> tasks) {
        LocalDateTime now = LocalDateTime.now();
        LocalDate nowDate = now.toLocalDate();
        ObservableList<VBox> todayTasks = FXCollections.observableArrayList();
        // index of task to scroll to
        int todayModified = UNMODIFIED;
        for (Task task : tasks) {
            VBox entry = createOngoingTaskEntry(task, now);
            if (task.isOccurringOn(nowDate)) {
                todayTasks.add(entry);
                if (task.isModified()) {
                    todayModified = todayTasks.size() - 1;
                }
            }
        }
        
        if (todayTasks.isEmpty()) {
            setEmptyMessageInList(todayList, MESSAGE_EMPTY_LIST_TODAY);
        } else {
            ListView<VBox> todayListView = createListView(todayTasks);
            if (!todayTasks.isEmpty()) {
                int numVisibleTasks = Math.min(todayTasks.size(), 3);
                todayListView.setMinHeight(CELL_MIN_HEIGHT * numVisibleTasks);
            }
            if (todayModified != UNMODIFIED) {
                todayListView.scrollTo(todayModified);
            }
            updateChildren(todayList, todayListView);
        }
    }

    private void populateOtherList(ArrayList<Task> tasks) {
        LocalDateTime now = LocalDateTime.now();
        LocalDate nowDate = now.toLocalDate();
        ObservableList<VBox> otherTasks = FXCollections.observableArrayList();
        // index of task to scroll to
        int otherModified = UNMODIFIED;
        for (Task task : tasks) {
            VBox entry = createOngoingTaskEntry(task, now);
            if (!task.isOccurringOn(nowDate)) {
                otherTasks.add(entry);
                if (task.isModified()) {
                    otherModified = otherTasks.size() - 1;
                }
            }
        }
        
        if (otherTasks.isEmpty()) {
            setEmptyMessageInList(otherList, MESSAGE_EMPTY_LIST_OTHER);
        } else {
            ListView<VBox> otherListView = createListView(otherTasks);
            if (!otherTasks.isEmpty()) {
                int numVisibleTasks = Math.min(otherTasks.size(), 2);
                otherListView.setMinHeight(CELL_MIN_HEIGHT * numVisibleTasks);
            }
            if (otherModified != UNMODIFIED) {
                otherListView.scrollTo(otherModified);
            }
            updateChildren(otherList, otherListView);
        }
    }

    private void setEmptyMessageInList(VBox list, String prompt) {
        Label info = new Label(prompt);
        info.getStyleClass().add("entry-empty");
        info.setMinHeight(USE_PREF_SIZE);
        updateChildren(list, info);
    }
    
    /****************************
     * METHOD TO UPDATE SIDEBAR *
     ****************************/
    
    /**
     * Populate the sidebar with the specified categories
     */
    private void populateSidebar(ArrayList<Category> categories) {
        categoryList.getChildren().clear();
        // add category name and corresponding task count to the next row
        for (int row = 0; row < categories.size(); row++) {
            Category cat = categories.get(row);
            Label name = new Label(cat.getName());
            name.getStyleClass().add("entry-cat");
            categoryList.add(name, 0, row);
            Label count = new Label(Integer.toString(cat.getCount()));
            count.getStyleClass().add("count");
            categoryList.add(count, 1, row);
        }
    }
    
    /**********************************
     * METHODS TO UPDATE SEARCH PANEL *
     **********************************/

    /**
     * Populate the search panel with the given search results
     */
    private void populateSearchPanel(ArrayList<Task> searchResults) {
        assert (searchResults != null);
        Label searchHeader = createHeader(searchResults.size(), HEADER_SEARCH_SINGLE, HEADER_SEARCH_PLURAL);
        ObservableList<VBox> searchTasks = createSearchTasks(searchResults);
        ListView<VBox> searchListView = createListView(searchTasks);
        updateChildren(searchPanel, searchHeader, searchListView);
    }
    
    private ObservableList<VBox> createSearchTasks(ArrayList<Task> tasks) {
        LocalDateTime todayDateTime = LocalDateTime.now();
        ObservableList<VBox> searchTasks = FXCollections.observableArrayList();
        for (Task task : tasks) {
            VBox entry = createOngoingTaskEntry(task, todayDateTime);
            searchTasks.add(entry);
        }
        return searchTasks;
    }
    
    /********************************
     * METHODS TO UPDATE DONE PANEL *
     ********************************/

    /**
     * Populate the done panel with the specified list of completed tasks
     */
    private void populateDonePanel(ArrayList<Task> tasks) {
        assert (tasks != null);
        Label doneHeader = createHeader(tasks.size(), HEADER_DONE_SINGLE, HEADER_DONE_PLURAL);
        ObservableList<VBox> doneTasks = createDoneTasks(tasks);
        ListView<VBox> doneListView = createListView(doneTasks);
        updateChildren(donePanel, doneHeader, doneListView);
    }

    private ObservableList<VBox> createDoneTasks(ArrayList<Task> tasks) {
        ObservableList<VBox> doneTasks = FXCollections.observableArrayList();
        for (Task task : tasks) {
            VBox entry = createDoneTaskEntry(task);
            doneTasks.add(entry);
        }
        return doneTasks;
    }
    
    /******************
     * HELPER METHODS *
     ******************/

    private void updateChildren(Pane parent, Node... children) {
        parent.getChildren().clear();
        parent.getChildren().addAll(children);
    }
    
    private Label createHeader(int size, String single, String plural) {
        String headerText = size + (size == 1 ? single : plural);
        Label header = new Label(headerText);
        header.getStyleClass().add("header");
        return header;
    }

    private ListView<VBox> createListView(ObservableList<VBox> tasks) {
        ListView<VBox> listView = new ListView<VBox>(tasks);
        // ListView's default height is fixed at 400 regardless of size of list
        // Workaround for resizing ListView by binding to (cell height * number)
        listView.maxHeightProperty().bind(Bindings.size(tasks).multiply(CELL_MIN_HEIGHT));
        VBox.setVgrow(listView, Priority.SOMETIMES);
        return listView;
    }
    
    private VBox createOngoingTaskEntry(Task task, LocalDateTime now) {
        Label description = formatOngoingTaskDescription(task);
        HBox details = formatOngoingTaskDetails(task, now);
        VBox entry = formatOngoingTaskEntry(task, now, description, details);
        return entry;
    }
    
    private Label formatOngoingTaskDescription(Task task) {
        int id = task.getId();
        String desc = task.getDescription();
        String descriptionText = id + ". " + desc;
        Label description = new Label(descriptionText);
        description.getStyleClass().add("desc");
        return description;
    }

    private HBox formatOngoingTaskDetails(Task task, LocalDateTime now) {
        HBox details = new HBox();
        details.getStyleClass().add("details");
        
        // add priority icon if task is important
        if (task.isImportant()) {
            ImageView icon = new ImageView(new Image(RESOURCES_ICON_PRIORITY));
            details.getChildren().add(icon);
        }
        
        // add date details if available
        LocalDate nowDate = now.toLocalDate();
        String startEndString = task.getRelativeStartEndString(nowDate);
        if (!startEndString.isEmpty()) {
            Label startEndDate = new Label(startEndString);
            details.getChildren().add(startEndDate);
        }
        
        // add categories if available
        String categoriesString = task.getCategoriesString();
        if (!categoriesString.isEmpty()) {
            Label categories = new Label(categoriesString);
            details.getChildren().add(categories);
        }
        
        return details;
    }

    private VBox formatOngoingTaskEntry(Task task, LocalDateTime now, Label description, HBox details) {
        VBox entry = new VBox();
        entry.getChildren().addAll(description, details);
        if (task.isModified()) {
            entry.getStyleClass().add("entry-task-modified");
        } else if (task.isOverdue(now)) {
            entry.getStyleClass().add("entry-task-overdue");
        } else {
            entry.getStyleClass().add("entry-task");
        }
        return entry;
    }

    private VBox createDoneTaskEntry(Task task) {
        Label description = formatDoneTaskDescription(task);
        HBox details = formatDoneTaskDetails(task);
        VBox entry = formatDoneTaskEntry(task, description, details);
        return entry;
    }
    
    private Label formatDoneTaskDescription(Task task) {
        String descriptionText = task.getDescription();
        Label description = new Label(descriptionText);
        description.getStyleClass().add("desc");
        return description;
    }
    
    private HBox formatDoneTaskDetails(Task task) {
        HBox details = new HBox();
        details.getStyleClass().add("details");
        
        // add priority icon if task is important
        if (task.isImportant()) {
            ImageView icon = new ImageView(new Image(RESOURCES_ICON_PRIORITY));
            details.getChildren().add(icon);
        }
        
        // add date details if available
        String startEndString = task.getStartEndString();
        if (!startEndString.isEmpty()) {
            Label startEndDate = new Label(startEndString);
            details.getChildren().add(startEndDate);
        }
        
        // add categories if available
        String categoriesString = task.getCategoriesString();
        if (!categoriesString.isEmpty()) {
            Label categories = new Label(categoriesString);
            details.getChildren().add(categories);
        }
        
        return details;
    }

    private VBox formatDoneTaskEntry(Task task, Label description, HBox details) {
        VBox entry = new VBox();
        entry.getChildren().addAll(description, details);
        entry.getStyleClass().add("entry-task");
        return entry;
    }

}
```
###### src\gridtask\ui\feedback.css
``` css
/* Defines the design of the feedback popup */

/* reduce font aliasing  */
.text {
    -fx-font-smoothing-type: gray;
}

#popup-box {
    -fx-background-color: #F4F4F4;
    -fx-padding: 5;
    -fx-spacing: 5;
    -fx-alignment: center-left;
}

#popup-text {
    -fx-font-size: 20;
    -fx-text-fill: #000000;
    -fx-font-family: "Roboto Regular", "Segoe UI", sans-serif;
    -fx-alignment: center-left;
    -fx-label-padding: 5;
}
```
###### src\gridtask\ui\Feedback.java
``` java
package gridtask.ui;

import gridtask.common.Result;
import javafx.event.EventHandler;
import javafx.scene.control.Label;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.HBox;
import javafx.stage.Popup;
import javafx.stage.Stage;

public class Feedback {
    
    Stage primaryStage;
    
    private Popup feedbackPopup;
    private HBox content;
    private ImageView icon;
    private Label message;
    
    private static final String RESOURCES_ICON_SUCCESS = "/icons/success-small.png";
    private static final String RESOURCES_ICON_SUCCESS_DELETE = "/icons/delete-success-small.png";
    private static final String RESOURCES_ICON_SUCCESS_SAVE = "/icons/save-success-small.png";
    private static final String RESOURCES_ICON_FAIL = "/icons/fail-small.png";
    private static final String RESOURCES_ICON_FAIL_DELETE = "/icons/delete-fail-small.png";
    private static final String RESOURCES_ICON_FAIL_SAVE = "/icons/save-fail-small.png";
    
    public Feedback(Stage primaryStage) {
        this.primaryStage = primaryStage;
        initializeContent();
        initializeFeedbackPopup();
    }

    private void initializeContent() {
        content = new HBox();
        content.getStylesheets().add(getClass().getResource("feedback.css").toExternalForm()); 
        content.setId("popup-box");
        
        message = new Label();
        message.setId("popup-text");
        icon = new ImageView();
        
        content.getChildren().addAll(icon, message);
    }
    
    private void initializeFeedbackPopup() {
        feedbackPopup = new Popup();
        // hide feedback popup when window loses focus
        feedbackPopup.setAutoHide(true);
        // hide feedback popup on any key press
        feedbackPopup.addEventFilter(KeyEvent.KEY_PRESSED, new EventHandler<KeyEvent>() {
            public void handle(KeyEvent event) {
                feedbackPopup.hide();
            }
        });
        feedbackPopup.getContent().add(content);
    }

    public void displayFeedback(Result result) {
        setFeedback(result);
        if (!isDisplayCommand(result)) {
            showFeedback();
        }
    }
    
    private boolean isDisplayCommand(Result result) {
        switch (result.getCommandType()) {
            case SEARCH :
                // fallthrough
            
            case SEARCHDONE :
                // fallthrough
            
            case HOME :
                // fallthrough
                
            case HELP :
                return true;
            
            default :
                return false;
        }
    }

    private void showFeedback() {
        // align to left of window
        double x = primaryStage.getX() + primaryStage.getScene().getX();
        feedbackPopup.setX(x);
        // align to bottom of window
        double y = primaryStage.getY() + primaryStage.getHeight();
        feedbackPopup.setY(y);
        feedbackPopup.show(primaryStage);
    }

    private void setFeedback(Result result) {
        assert (result != null);
        String msg = result.getMessage();
        message.setText(msg);
        Image img = getIcon(result);
        icon.setImage(img);
    }
    
    private Image getIcon(Result result) {
        String resource;
        switch (result.getCommandType()) {
            case DELETE :
                resource = result.isSuccess() ? RESOURCES_ICON_SUCCESS_DELETE : RESOURCES_ICON_FAIL_DELETE;
                break;
                
            case SAVE :
                // fallthrough
            
            case LOAD :
                resource = result.isSuccess() ? RESOURCES_ICON_SUCCESS_SAVE : RESOURCES_ICON_FAIL_SAVE;
                break;
                
            default :
                resource = result.isSuccess() ? RESOURCES_ICON_SUCCESS : RESOURCES_ICON_FAIL;
                break;
        }
        return new Image(resource);
    }
    
}
```
###### src\gridtask\ui\input.css
``` css
.text {
    -fx-font-smoothing-type: gray;
}

.label {
    -fx-font-size: 15;
    -fx-font-family: "Roboto Regular", "Segoe UI", sans-serif;
    -fx-alignment: center-left;
    -fx-label-padding: 5;
}

.text-field {
    -fx-background-color: #FFFFFF;
    -fx-font-size: 18;
    -fx-font-family: "Roboto Regular", "Segoe UI", sans-serif;
    -fx-highlight-fill: #A1E7C6;
    -fx-highlight-text-fill: #FFFFFF;
}
```
###### src\gridtask\ui\Input.fxml
``` fxml
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.control.TextField?>
<?import java.net.URL?>

<fx:root xmlns:fx="http://javafx.com/fxml/1" type="VBox">
	<TextField fx:id="commandBar" promptText="Enter your command here!" onAction="#readInput" >
    </TextField>
    
    <stylesheets>
        <URL value="@input.css" />
    </stylesheets>
</fx:root>
```
###### src\gridtask\ui\InputController.java
``` java
package gridtask.ui;

import java.io.IOException;
import java.util.logging.FileHandler;
import java.util.logging.Handler;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;

import org.controlsfx.control.textfield.AutoCompletionBinding;
import org.controlsfx.control.textfield.TextFields;

import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.control.TextField;
import javafx.scene.layout.VBox;

public class InputController extends VBox {

    private static Logger logger = Logger.getLogger("MainApp.InputController");
    private MainApp main;
    @FXML TextField commandBar;

    private static final String FXML_INPUT = "Input.fxml";

    public InputController(MainApp main) {
        this.main = main;
        initializeLogger();
        loadFXML();
        bindAutoCompletion();
    }

    private void initializeLogger() {
        try {
            Handler fh = new FileHandler("log_ui_input");
            logger.addHandler(fh);
            SimpleFormatter formatter = new SimpleFormatter();  
            fh.setFormatter(formatter);
        } catch (SecurityException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void loadFXML() {
        FXMLLoader loader = new FXMLLoader(getClass().getResource(FXML_INPUT));
        loader.setController(this);
        loader.setRoot(this);
        try {
            loader.load();
        } catch (IOException e) {
            logger.severe("failed to load Input");
        }
    }
    
    private void bindAutoCompletion() {
        AutoCompletionBinding<String> binding = TextFields.bindAutoCompletion(commandBar, sr -> {
            return main.getPredictions(commandBar.getText());
        });
    }
    
    @FXML
    private void readInput(ActionEvent event) {
        String input = commandBar.getText();
        logger.info("user entered: " + input);
        commandBar.clear();
        main.handleCommand(input);
    }

}
```
###### src\gridtask\ui\MainApp.java
``` java
package gridtask.ui;

import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;

import gridtask.common.Category;
import gridtask.common.Result;
import gridtask.common.Task;
import gridtask.logic.Logic;
import javafx.application.Application;
import javafx.event.EventHandler;
import javafx.scene.Scene;
import javafx.scene.image.Image;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.BorderPane;
import javafx.scene.text.Font;
import javafx.stage.Stage;

public class MainApp extends Application {

    private static Logger logger = Logger.getLogger("MainApp");
    private Logic logic;
    private BorderPane root;
    private DisplayController display;
    private InputController input;
    private Feedback feedback;
 
    private static final int WINDOW_WIDTH_MIN = 400;
    private static final int WINDOW_HEIGHT_MIN = 380;
    private static final int WINDOW_WIDTH_DEFAULT = 650;
    private static final int WINDOW_HEIGHT_DEFAULT = 500;
    
    private static final String RESOURCES_ICON_PROGRAM = "/icons/logo-smaller.png";
    private static final String RESOURCES_FONT_ROBOTO = "/fonts/Roboto-Regular.ttf";
    private static final String RESOURCES_FONT_ROBOTO_SLAB = "/fonts/RobotoSlab-Regular.ttf";
    private static final String RESOURCES_FONT_ROBOTO_CONDENSED = "/fonts/RobotoCondensed-Regular.ttf";
    private static final String RESOURCES_FONT_ROBOTO_BOLD = "/fonts/Roboto-Bold.ttf";
    
    public static void main(String[] args) {
        launch(args);
    }
    
    public void start(Stage primaryStage) {
        logger.log(Level.INFO, "initalizing components");
        initializeLogic();
        initializeWindow(primaryStage);
        initializeUI(primaryStage);
    }
    
    private void initializeLogic() {
        logic = Logic.getInstance();
    }

    private void initializeWindow(Stage primaryStage) {
        primaryStage.getIcons().add(new Image(RESOURCES_ICON_PROGRAM));
        primaryStage.setMinWidth(WINDOW_WIDTH_MIN);
        primaryStage.setMinHeight(WINDOW_HEIGHT_MIN);
        root = new BorderPane();
        Scene scene = new Scene(root, WINDOW_WIDTH_DEFAULT, WINDOW_HEIGHT_DEFAULT);
        primaryStage.setScene(scene);
        primaryStage.show();
    }
    
    private void initializeUI(Stage primaryStage) {
        Font.loadFont(getClass().getResource(RESOURCES_FONT_ROBOTO).toExternalForm(), 20);
        Font.loadFont(getClass().getResource(RESOURCES_FONT_ROBOTO_SLAB).toExternalForm(), 20);
        Font.loadFont(getClass().getResource(RESOURCES_FONT_ROBOTO_CONDENSED).toExternalForm(), 20);
        Font.loadFont(getClass().getResource(RESOURCES_FONT_ROBOTO_BOLD).toExternalForm(), 20);
        display = new DisplayController(this);
        input = new InputController(this);
        root.setCenter(display);
        root.setBottom(input);
        root.addEventFilter(KeyEvent.KEY_PRESSED, new EventHandler<KeyEvent>() {
            public void handle(KeyEvent event) {
                if (event.getCode()==KeyCode.M && event.isControlDown()) {
                    logger.log(Level.INFO, "user toggled sidebar");
                    display.toggleSidebar();
                }
            }
        });
        feedback = new Feedback(primaryStage);
    }

    /* ||||||||||||||||||||||||||||||||||||||||||
     * ||                                      ||
     * ||   METHODS THAT INTERACT WITH LOGIC   ||
     * ||                                      ||
     * ||||||||||||||||||||||||||||||||||||||||||
     */

    public ArrayList<Task> getTasks() {
        Result result = logic.processCommand("home");
        assert (result != null);
        ArrayList<Task> tasks = result.getResults();
        return tasks;
    }

    public ArrayList<Category> getCategories() {
        ArrayList<Category> categories = logic.getCategories();
        return categories;
    }
    
    public void handleCommand(String input) {
        Result result = logic.processCommand(input);
        display.displayResult(result);
        feedback.displayFeedback(result);
    }

    public ArrayList<String> getPredictions(String input) {
        return logic.getPredictions(input);
    }

}
```
###### testing\LogicTest.java
``` java
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertArrayEquals;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.time.LocalDateTime;
import java.util.ArrayList;

import org.junit.Test;

import gridtask.common.*;
import gridtask.logic.Logic;
import junitx.framework.FileAssert;

public class LogicTest {
    
    Logic logic = Logic.getInstance();

    @Test
    public void addTask_MissingDescription_InvalidCommand() {
        Result noSpace = logic.processCommand("add");
        assertEquals(Command.CommandType.ADD, noSpace.getCommandType());
        assertEquals(false, noSpace.isSuccess());
        
        Result noDescAfterSpace = logic.processCommand("add  ");
        assertEquals(Command.CommandType.ADD, noDescAfterSpace.getCommandType());
        assertEquals(false, noSpace.isSuccess());
        
    /*    Result noDescWithDate = logic.processCommand("add end today");
        assertEquals(Command.CommandType.ADD, noDescWithDate.getCommandType());
        assertEquals(false, noSpace.isSuccess());*/
    }
    
    @Test
    public void addTask_InvalidDate_InvalidCommand() {
        Result laterStart = logic.processCommand("add 111 start 01/01/2016 12:00 end 31/12/2015 12:00");
        assertEquals(Command.CommandType.INVALID, laterStart.getCommandType());
    }
    
    @Test
    public void addTask_AllTaskTypes_AddedInOrder() {
        createEmptyFile("output_addTask_AllTaskTypes.txt");
        logic.processCommand("load output_addTask_AllTaskTypes.txt");
        
        logic.processCommand("add Hello");
        logic.processCommand("add Goodbye");
        logic.processCommand("add Meeting start 24/05/2016 14:00");
        logic.processCommand("add Meeting end 25/05/2016 14:00");
        logic.processCommand("add Meeting end 24/05/2016 14:00");
        logic.processCommand("add Meeting start 24/05/2016 12:00 end 26/05/2016 14:00");
        
        File expectedFile = new File("testing/expected_addTask_AllTaskTypes.txt");
        File actualFile = new File("output_addTask_AllTaskTypes.txt");
        FileAssert.assertEquals(expectedFile, actualFile);
    }
    
    @Test
    public void deleteTask_ValidTaskNumber_DeletedSelectedTask() {
        logic.processCommand("load testing/input_deleteTask_ValidTaskNumber.txt");
        logic.processCommand("save output_deleteTask_ValidTaskNumber.txt");
        
        logic.processCommand("delete 6");
        logic.processCommand("delete 1");
        logic.processCommand("delete 1");
        
        File expectedFile = new File("testing/expected_deleteTask_ValidTaskNumber.txt");
        File actualFile = new File("output_deleteTask_ValidTaskNumber.txt");
        FileAssert.assertEquals(expectedFile, actualFile);
    }
    
    @Test
    public void doneTask_ValidTaskNumber_MarkAsDone() {
        logic.processCommand("load testing/input_doneTask_ValidTaskNumber.txt");
        logic.processCommand("save output_doneTask_ValidTaskNumber.txt");
        
        logic.processCommand("done 6");
        logic.processCommand("done 1");
        logic.processCommand("done 1");
        
        File expectedFile = new File("testing/expected_doneTask_ValidTaskNumber.txt");
        File actualFile = new File("output_doneTask_ValidTaskNumber.txt");
        FileAssert.assertEquals(expectedFile, actualFile);
    }
    
    @Test
    public void editTask_ValidTaskNumber_EditedSelectedTask() {
        logic.processCommand("load testing/input_editTask_AllTaskTypes.txt");
        logic.processCommand("save output_editTask_AllTaskTypes.txt");
        
        logic.processCommand("edit 6 Meeting start 24/05/2016 12:00 end 30/05/2016 14:00");
        logic.processCommand("edit 6 Hello world");
        
        File expectedFile = new File("testing/expected_editTask_AllTaskTypes.txt");
        File actualFile = new File("output_editTask_AllTaskTypes.txt");
        FileAssert.assertEquals(expectedFile, actualFile);
    }

    @Test
    public void saveTasks_WithFileName_Success() {
        createEmptyFile("output_saveTasks_WithFileName.txt");
        logic.processCommand("load output_saveTasks_WithFileName.txt");
        logic.processCommand("add Meeting start 24/05/2016 12:00 end 26/05/2016 14:00");
        logic.processCommand("add Meeting end 24/05/2016 14:00");
        logic.processCommand("add Goodbye");
        logic.processCommand("add Meeting start 24/05/2016 14:00");
        logic.processCommand("done 1");
        logic.processCommand("done 1");
        logic.processCommand("done 1");
        logic.processCommand("done 1");
        logic.processCommand("add Meeting start 24/05/2016 12:00 end 26/05/2016 14:00");
        logic.processCommand("add Meeting end 24/05/2016 14:00");
        logic.processCommand("add Goodbye");
        logic.processCommand("add Meeting start 24/05/2016 14:00");
        
        Result result = logic.processCommand("save output_saveTasks_WithFileName.txt");
        assertEquals(Command.CommandType.SAVE, result.getCommandType());
        assertEquals(true, result.isSuccess());
        
        File expectedFile = new File("testing/expected_saveTasks_WithFileName.txt");
        File actualFile = new File("output_saveTasks_WithFileName.txt");
        FileAssert.assertEquals(expectedFile, actualFile);
    }

    @Test
    public void loadTasks_WithFileName_Success() {
        Result result = logic.processCommand("load testing/input_loadTasks_WithFileName.txt");
        assertEquals(Command.CommandType.LOAD, result.getCommandType());
        assertEquals(true, result.isSuccess());
        
        ArrayList<Task> expectedMainList = new ArrayList<Task>();
        expectedMainList.add(new Task("Meeting", null, 
                LocalDateTime.of(2016, 05, 24, 14, 0), 1));
        expectedMainList.add(new Task("Meeting", LocalDateTime.of(2016, 05, 24, 12, 0), 
                LocalDateTime.of(2016, 05, 26, 14, 0), 2));
        expectedMainList.add(new Task("Goodbye", null, null, 3));
        expectedMainList.add(new Task("Meeting", LocalDateTime.of(2016, 05, 24, 14, 0), null, 4));
        
        ArrayList<Task> actualMainList = logic.getMainList();
        assertArrayEquals(expectedMainList.toArray(), actualMainList.toArray());

        ArrayList<Task> expectedDoneList = new ArrayList<Task>();
        expectedDoneList.add(new Task("Meeting", null, 
                LocalDateTime.of(2016, 05, 24, 14, 0)));
        expectedDoneList.add(new Task("Meeting", LocalDateTime.of(2016, 05, 24, 12, 0), 
                LocalDateTime.of(2016, 05, 26, 14, 0)));
        expectedDoneList.add(new Task("Goodbye", null, null));
        expectedDoneList.add(new Task("Meeting", LocalDateTime.of(2016, 05, 24, 14, 0), null));
        
        ArrayList<Task> actualDoneList = logic.getDoneList();
        assertArrayEquals(expectedDoneList.toArray(), actualDoneList.toArray());
    }
    
    @Test
    public void search_NoParam_DisplayAll() {
        logic.processCommand("load testing/input_search.txt");
        File expectedFile = new File("testing/expected_search_NoParam.txt");
        File actualFile;
        
        Result noSpace = logic.processCommand("search");
        actualFile = saveSearchResults("output_search_NoParam.txt", noSpace.getResults());
        assertEquals(Command.CommandType.SEARCH, noSpace.getCommandType());
        FileAssert.assertEquals(expectedFile, actualFile);

        Result hasWhitespace = logic.processCommand("search  ");
        actualFile = saveSearchResults("output_search_NoParam.txt", hasWhitespace.getResults());
        assertEquals(Command.CommandType.SEARCH, hasWhitespace.getCommandType());
        FileAssert.assertEquals(expectedFile, actualFile);
    }
    
    @Test
    public void search_KeywordExists_DisplayMatching() {
        logic.processCommand("load testing/input_search.txt");
        File expectedFile = new File("testing/expected_search_KeywordExists.txt");
        File actualFile;
        
        Result word = logic.processCommand("search aAA");
        actualFile = saveSearchResults("output_search_KeywordExists.txt",
                word.getResults());
        FileAssert.assertEquals(expectedFile, actualFile);

        Result wordWithWhitespace = logic.processCommand("search aAA   ");
        actualFile = saveSearchResults("output_search_KeywordExists.txt",
                wordWithWhitespace.getResults());
        FileAssert.assertEquals(expectedFile, actualFile);
    }
    
    /*@Test  NOT DONE!!
    public void search_DateExists_DisplayMatching() {
        logic.processCommand("load testing/input_search.txt");
        File expectedFile = new File("testing/expected_search_DateExists.txt");
        File actualFile;
        
        Result date = logic.processCommand("search start 07/07/2016");
        actualFile = saveSearchResults("output_search_DateExists.txt",
                date.getResults());
        FileAssert.assertEquals(expectedFile, actualFile);

        Result dateWithWhitespace = logic.processCommand("search start 07/07/2016   ");
        actualFile = saveSearchResults("output_search_DateExists.txt",
                dateWithWhitespace.getResults());
        FileAssert.assertEquals(expectedFile, actualFile);
    }
     */ 
    @Test
    public void search_CategoryExists_DisplayMatching() {
        logic.processCommand("load testing/input_search.txt");
        File expectedFile = new File("testing/expected_search_CategoryExists.txt");
        File actualFile;
        
        Result category = logic.processCommand("search #Zzzzz");
        actualFile = saveSearchResults("output_search_CategoryExists.txt",
                category.getResults());
        FileAssert.assertEquals(expectedFile, actualFile);

        Result categoryWithWhitespace = logic.processCommand("search #Zzzzz   ");
        actualFile = saveSearchResults("output_search_CategoryExists.txt",
                categoryWithWhitespace.getResults());
        FileAssert.assertEquals(expectedFile, actualFile);
    }

    @Test
    public void searchDone_NoParam_DisplayAll() {
        logic.processCommand("load testing/input_search.txt");
        File expectedFile = new File("testing/expected_searchDone_NoParam.txt");
        File actualFile;
        
        Result noSpace = logic.processCommand("searchdone");
        actualFile = saveSearchDoneResults("output_searchDone_NoParam.txt", noSpace.getResults());
        assertEquals(Command.CommandType.SEARCHDONE, noSpace.getCommandType());
        FileAssert.assertEquals(expectedFile, actualFile);

        Result hasWhitespace = logic.processCommand("searchdone  ");
        actualFile = saveSearchDoneResults("output_searchDone_NoParam.txt", hasWhitespace.getResults());
        assertEquals(Command.CommandType.SEARCHDONE, hasWhitespace.getCommandType());
        FileAssert.assertEquals(expectedFile, actualFile);
    }
    
    /* @Test NOT DONE !!!1
    public void searchDone_DateExists_DisplayMatching() {
        logic.processCommand("load testing/input_search.txt");
        File expectedFile = new File("testing/expected_searchDone_DateExists.txt");
        File actualFile;
        
        Result date = logic.processCommand("searchdone start 07/07/2016");
        actualFile = saveSearchDoneResults("output_searchDone_DateExists.txt",
                date.getResults());
        FileAssert.assertEquals(expectedFile, actualFile);

        Result dateWithWhitespace = logic.processCommand("searchdone start 07/07/2016   ");
        actualFile = saveSearchDoneResults("output_searchDone_DateExists.txt",
                dateWithWhitespace.getResults());
        FileAssert.assertEquals(expectedFile, actualFile);
    } */
    
    @Test
    public void searchDone_KeywordExists_DisplayMatching() {
        logic.processCommand("load testing/input_search.txt");
        File expectedFile = new File("testing/expected_searchDone_KeywordExists.txt");
        File actualFile;
        
        Result word = logic.processCommand("searchdone cCC");
        actualFile = saveSearchDoneResults("output_searchDone_KeywordExists.txt",
                word.getResults());
        FileAssert.assertEquals(expectedFile, actualFile);

        Result wordWithWhitespace = logic.processCommand("searchdone cCC   ");
        actualFile = saveSearchDoneResults("output_searchDone_KeywordExists.txt",
                wordWithWhitespace.getResults());
        FileAssert.assertEquals(expectedFile, actualFile);
    }
    
    @Test
    public void undo_AfterAllowedCommand_ReturnToPreviousState() {
        createEmptyFile("output_undo_AfterAllowedCommand.txt");
        logic.processCommand("load testing/input_undo.txt");
        logic.processCommand("save output_undo_AfterAllowedCommand.txt");
        
        logic.processCommand("add Marshmallow start 05/10/2015");
        logic.processCommand("add N");
        logic.processCommand("undo");
        logic.processCommand("edit 3 Ice Cream Sandwich start 18/10/2011");
        logic.processCommand("edit 5 Key Lime Pie");
        logic.processCommand("undo");
        logic.processCommand("delete 2");
        logic.processCommand("delete 2");
        logic.processCommand("undo");
        logic.processCommand("done 1");
        logic.processCommand("done 1");
        logic.processCommand("undo");
    
        File expectedFile = new File("testing/expected_undo_AfterAllowedCommand.txt");
        File actualFile = new File("output_undo_AfterAllowedCommand.txt");
        FileAssert.assertEquals(expectedFile, actualFile);
    }
    
    @Test
    public void undo_AfterUnallowedCommand_NoChange() {
        createEmptyFile("output_undo_AfterUnallowedCommand.txt");
        logic.processCommand("load testing/input_undo.txt");
        
        Result undoAfterLoad = logic.processCommand("undo");
        assertEquals(Command.CommandType.UNDO, undoAfterLoad.getCommandType());
        assertEquals(false, undoAfterLoad.isSuccess());
        
        logic.processCommand("save output_undo_AfterUnallowedCommand.txt");

        Result undoAfterSave = logic.processCommand("undo");
        assertEquals(Command.CommandType.UNDO, undoAfterSave.getCommandType());
        assertEquals(false, undoAfterSave.isSuccess());
        
        logic.processCommand("search e");
        Result undoAfterSearch = logic.processCommand("undo");
        assertEquals(Command.CommandType.UNDO, undoAfterSearch.getCommandType());
        assertEquals(false, undoAfterSearch.isSuccess());
        
        logic.processCommand("home");
        Result undoAfterHome = logic.processCommand("undo");
        assertEquals(Command.CommandType.UNDO, undoAfterHome.getCommandType());
        assertEquals(false, undoAfterHome.isSuccess());
                
        File expectedFile = new File("testing/expected_undo_AfterUnallowedCommand.txt");
        File actualFile = new File("output_undo_AfterUnallowedCommand.txt");
        FileAssert.assertEquals(expectedFile, actualFile);
    }
    
    @Test
    public void redo_AfterUndo_ReturnToCurrentState() {
        createEmptyFile("output_redo_AfterUndo.txt");
        logic.processCommand("load testing/input_redo.txt");
        logic.processCommand("save output_redo_AfterUndo.txt");
        
        logic.processCommand("add Marshmallow start 05/10/2015");
        logic.processCommand("undo");
        logic.processCommand("redo");
        logic.processCommand("edit 4 Key Lime Pie");
        logic.processCommand("undo");
        logic.processCommand("redo");
        logic.processCommand("delete 2");
        logic.processCommand("undo");
        logic.processCommand("redo");
        logic.processCommand("done 1");
        logic.processCommand("undo");
        logic.processCommand("redo");
    
        File expectedFile = new File("testing/expected_redo_AfterUndo.txt");
        File actualFile = new File("output_redo_AfterUndo.txt");
        FileAssert.assertEquals(expectedFile, actualFile);
    }
    
    @Test
    public void redo_AfterUnallowedCommand_NoChange() {
        createEmptyFile("output_redo_AfterUnallowedCommand.txt");
        logic.processCommand("load testing/input_redo.txt");
        logic.processCommand("save output_redo_AfterUnallowedCommand.txt");
        
        logic.processCommand("add Donut");
        logic.processCommand("undo");
        logic.processCommand("add Eclair");
        Result result = logic.processCommand("redo");
        assertEquals(Command.CommandType.REDO, result.getCommandType());
        assertEquals(false, result.isSuccess());
        
        File expectedFile = new File("testing/expected_redo_AfterUnallowedCommand.txt");
        File actualFile = new File("output_redo_AfterUnallowedCommand.txt");
        FileAssert.assertEquals(expectedFile, actualFile);
    }
    
    private static File createEmptyFile(String fileName) {
        File file = new File(fileName);
        try (BufferedWriter buffWriter = new BufferedWriter(new FileWriter(file))) {
            buffWriter.write("");
        } catch (IOException ioe) {
            ioe.printStackTrace();
        }
        return file;
    }
    
    private static File saveSearchResults(String fileName, ArrayList<Task> results) {
        File file = createEmptyFile(fileName);
        try (BufferedWriter buffWriter = new BufferedWriter(new FileWriter(file))) {
            for (Task task : results) {
                String str = task.toString();
                buffWriter.append(str);
                buffWriter.newLine();
            }
        } catch (IOException ioe) {
            ioe.printStackTrace();
        }
        return file;
    }
    
    private static File saveSearchDoneResults(String fileName, ArrayList<Task> results) {
        File file = createEmptyFile(fileName);
        try (BufferedWriter buffWriter = new BufferedWriter(new FileWriter(file))) {
            for (Task task : results) {
                String str = task.toStringIgnoreId();
                buffWriter.append(str);
                buffWriter.newLine();
            }
        } catch (IOException ioe) {
            ioe.printStackTrace();
        }
        return file;
    }
    
}
```
###### testing\TaskTest.java
``` java
import static org.junit.Assert.*;

import java.text.ParseException;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

import org.junit.Test;

import gridtask.common.Task;

public class TaskTest {
    
    private static DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm");

    private static final String DATE_FIRST = "01/04/2016 12:00";
    private static final String DATE_SECOND = "07/07/2016 12:00";
    private static final String DATE_THIRD = "31/12/2016 12:00";
    private static final String TASK_DESCRIPTION_FIRST = "aaa";
    private static final String TASK_DESCRIPTION_SECOND = "bbb";
    private static final String TASK_DESCRIPTION_THIRD = "ccc";
    
    /*
     * Equivalence partitioning:
     * Using 1/1/2016 as the point of comparison,
     * start and end dates can take up the possible values
     * [between "1/1/2016 00:00" and "1/1/2016 23:59"],
     * [<= "31/12/2015 23:59"], [>= "2/1/2016 00:00"], [null]
     * 
     */
    @Test
    public void isOccurringOn_CompareGivenDate_ExpectedBoolean() throws ParseException {
        LocalDate date = LocalDateTime.parse("01/01/2016 12:00", formatter).toLocalDate();

        Task floating = new Task(TASK_DESCRIPTION_SECOND);
        assertFalse(floating.isOccurringOn(date));
        
        Task deadlineSameEnd0000 = new Task(TASK_DESCRIPTION_SECOND);
        deadlineSameEnd0000.setEnd("01/01/2016 00:00");
        assertTrue(deadlineSameEnd0000.isOccurringOn(date));
        
        Task deadlineSameEnd2359 = new Task(TASK_DESCRIPTION_SECOND);
        deadlineSameEnd2359.setEnd("01/01/2016 23:59");
        assertTrue(deadlineSameEnd2359.isOccurringOn(date));
        
        Task deadlineDiffEnd0000 = new Task(TASK_DESCRIPTION_SECOND);
        deadlineDiffEnd0000.setEnd("02/01/2016 00:00");
        assertFalse(deadlineDiffEnd0000.isOccurringOn(date));
        
        Task deadlineDiffEnd2359 = new Task(TASK_DESCRIPTION_SECOND);
        deadlineDiffEnd2359.setEnd("31/12/2015 23:59");
        assertFalse(deadlineDiffEnd2359.isOccurringOn(date));

        Task eventSameStart = new Task(TASK_DESCRIPTION_SECOND);
        eventSameStart.setStart("01/01/2016 00:00");
        eventSameStart.setEnd("31/12/2016 00:00");
        assertTrue(eventSameStart.isOccurringOn(date));
        
        Task eventSameEnd = new Task(TASK_DESCRIPTION_SECOND);
        eventSameEnd.setStart("31/12/2015 23:59");
        eventSameEnd.setEnd("01/01/2016 23:59");
        assertTrue(eventSameStart.isOccurringOn(date));
    }
    
    @Test
    public void compareTo_FloatingTask_ExpectedReturnValue() throws ParseException {
        LocalDateTime date = LocalDateTime.parse(DATE_FIRST, formatter);
        Task floating = new Task(TASK_DESCRIPTION_SECOND);
        
        Task t2 = new Task(TASK_DESCRIPTION_SECOND);
        assertTrue("t2 is floating with same desc", floating.compareTo(t2) == 0);
        
        Task t3 = new Task(TASK_DESCRIPTION_THIRD);
        assertTrue("t3 is floating with greater desc", floating.compareTo(t3) < 0);
        t3.setDescription(TASK_DESCRIPTION_FIRST);
        assertTrue("t3 is floating with smaller desc", floating.compareTo(t3) > 0);
        
        Task t4 = new Task(TASK_DESCRIPTION_FIRST);
        t4.setEnd(date);
        assertTrue("t4 is non-floating", floating.compareTo(t4) > 0);
    }
    
    @Test
    public void compareTo_DeadlineTask_ExpectedReturnValue() throws ParseException {
        LocalDateTime firstDate = LocalDateTime.parse(DATE_FIRST, formatter);
        LocalDateTime secondDate = LocalDateTime.parse(DATE_SECOND, formatter);
        LocalDateTime thirdDate = LocalDateTime.parse(DATE_THIRD, formatter);
        Task deadline = new Task(TASK_DESCRIPTION_SECOND);
        deadline.setEnd(secondDate);
        
        Task t2 = new Task(TASK_DESCRIPTION_SECOND);
        assertTrue("t2 is floating", deadline.compareTo(t2) < 0);
        
        Task t3 = new Task(TASK_DESCRIPTION_SECOND);
        t3.setEnd(secondDate);
        assertTrue("t3 is deadline with same date, same desc", deadline.compareTo(t3) == 0);
        t3.setDescription(TASK_DESCRIPTION_FIRST);
        assertTrue("t3 is deadline with same date, diff desc", deadline.compareTo(t3) != 0);
        
        Task t4 = new Task(TASK_DESCRIPTION_SECOND);
        t4.setEnd(firstDate);
        assertTrue("t4 is deadline with smaller date, same desc", deadline.compareTo(t4) > 0);
        t4.setEnd(thirdDate);
        assertTrue("t4 is deadline with greater date, same desc", deadline.compareTo(t4) < 0);
        
        Task t5 = new Task(TASK_DESCRIPTION_SECOND);
        t5.setStart(secondDate);
        t5.setEnd(secondDate);
        assertTrue("t6 is event with same end date, same desc", deadline.compareTo(t5) == 0);
        t5.setDescription(TASK_DESCRIPTION_FIRST);
        assertTrue("t6 is event with same end date, diff desc", deadline.compareTo(t5) != 0);
    }
    
    @Test
    public void compareTo_EventTask_ExpectedReturnValue() throws ParseException {
        LocalDateTime firstDate = LocalDateTime.parse(DATE_FIRST, formatter);
        LocalDateTime secondDate = LocalDateTime.parse(DATE_SECOND, formatter);
        LocalDateTime thirdDate = LocalDateTime.parse(DATE_THIRD, formatter);
        Task event = new Task(TASK_DESCRIPTION_SECOND);
        event.setStart(secondDate);
        event.setEnd(secondDate);
        
        Task t2 = new Task(TASK_DESCRIPTION_SECOND);
        assertTrue("t2 is floating", event.compareTo(t2) < 0);
        
        Task t3 = new Task(TASK_DESCRIPTION_SECOND);
        t3.setEnd(secondDate);
        assertTrue("t3 is deadline with same end date, same desc", event.compareTo(t3) == 0);
        t3.setDescription(TASK_DESCRIPTION_FIRST);
        assertTrue("t3 is deadline with same end date, diff desc", event.compareTo(t3) != 0);
        
        Task t4 = new Task(TASK_DESCRIPTION_SECOND);
        t4.setStart(secondDate);
        t4.setEnd(secondDate);
        assertTrue("t4 is event with same start/end date, same desc", event.compareTo(t4) == 0);
        t4.setDescription(TASK_DESCRIPTION_FIRST);
        assertTrue("t4 is event with same start/end date, diff desc", event.compareTo(t4) != 0);
        
        Task t5 = new Task(TASK_DESCRIPTION_SECOND);
        t5.setStart(firstDate);
        t5.setEnd(secondDate);
        assertTrue("t5 is event with smaller start, same end", event.compareTo(t5) > 0);
        t5.setStart(secondDate);
        t5.setEnd(thirdDate);
        assertTrue("t5 is event with same start, greater end", event.compareTo(t5) < 0);
        
        Task t6 = new Task(TASK_DESCRIPTION_SECOND);
        t6.setStart(firstDate);
        t6.setEnd(firstDate);
        assertTrue("t6 is event with smaller start/end", event.compareTo(t6) > 0);
        t6.setStart(thirdDate);
        t6.setEnd(thirdDate);
        assertTrue("t6 is event with greater start/end", event.compareTo(t6) < 0);
        
        Task t7 = new Task(TASK_DESCRIPTION_SECOND);
        t7.setStart(firstDate);
        t7.setEnd(thirdDate);
        assertTrue("t7 is event with smaller start, greater end", event.compareTo(t7) < 0);
        assertTrue("t7 is event with smaller start, greater end", t7.compareTo(event) > 0);
    }
}
```
